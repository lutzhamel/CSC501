%% for equivalence proofs note that the if direction suffices -- there is nothing to prove in the only-if direction

\documentclass{beamer}
\include{defs}
\begin{document}

\begin{frame}{Arithmetic Expression Summary}
\scriptsize
%\begin{prooftree}
\AxiomC{}
\RightLabel{\hspace{.1in}for $n\in \syntaxset{I}$}
\UnaryInfC{$( n, \sigma ) \mapsto \mathit{eval}(n)$}
\DisplayProof\\
\vspace{.2in}
%\end{prooftree}
%\begin{prooftree}
\AxiomC{}
\RightLabel{\hspace{.1in}for $x\in \syntaxset{Loc}$}
\UnaryInfC{$( x, \sigma ) \mapsto \sigma(x)$}
\DisplayProof\\
\vspace{.2in}
%\end{prooftree}
%\begin{prooftree}
\AxiomC{$( a_0,\sigma) \mapsto k_0$}
\AxiomC{$( a_1,\sigma) \mapsto k_1$}
\RightLabel{\hspace{.1in}\small where $k= k_0 + k_1$}
\BinaryInfC{$( a_0 + a_1, \sigma) \mapsto k$}
\DisplayProof\\
\vspace{.2in}
% \end{prooftree}
%\begin{prooftree}
\AxiomC{$( a_0,\sigma) \mapsto k_0$} 
 \AxiomC{$( a_1,\sigma) \mapsto k_1$}
 \RightLabel{\hspace{.1in}\small where $k = k_0 - k_1$}
 \BinaryInfC{$( a_0 - a_1, \sigma) \mapsto k$}
\DisplayProof\\
\vspace{.2in}
% \end{prooftree}
%\begin{prooftree}
\AxiomC{$( a_0,\sigma) \mapsto k_0$} 
\AxiomC{$( a_1,\sigma) \mapsto k_1$}
\RightLabel{\hspace{.1in}\small where $k = k_0 \times k_1$}
\BinaryInfC{$( a_0 * a_1, \sigma) \mapsto k$}
\DisplayProof\\
\vspace{.2in}
%\end{prooftree}
\AxiomC{$( a,\sigma) \mapsto k$} 
\UnaryInfC{$( (a), \sigma) \mapsto k$}
\DisplayProof\\
\vspace{.2in}
with $k$, $k_0$, $k_1  \in \mathbb{I}$, $a$,$a_0$, $a_1 \in \syntaxset{Aexp}$, and 
$\sigma \in \Sigma$.
\end{frame}

\begin{frame}{Expression Equivalence}
Our notion of semantic value for expressions leads to a natural equivalence relation
between arithmetic expressions:

\[
a_0 \sim a_1 \mbox{ iff } 
\forall \sigma \in \Sigma, \exists n \in {\mathbb{I}} . \; 
( a_0,\sigma) \mapsto n
\wedge
( a_1,\sigma) \mapsto n,
\]
where $a_0$, $a_1 \in \syntaxset{Aexp}$.

\begin{quote}
\it\small Two expressions are equivalent if and only if they evaluate to the same semantic value in all possible states. 
\end{quote}
(You
should convince yourself that this is indeed an equivalence relation, i.e., check that
the relation $\sim$ is reflexive, symmetric, and transitive.)


\end{frame}

\begin{frame}{Expression Equivalence}

{\bf Problem:} Let $a_0 \equiv 2 * 3$ and $a_1 \equiv 3 + 3$, show that $a_0 \sim a_1$.
\end{frame}

\begin{frame}{Expression Equivalence}
\small
{\it Proof}: We need to show that  
$
(  2 * 3,\sigma) \mapsto k
$
and 
$
( 3 + 3,\sigma) \mapsto k
$
for all states $\sigma \in \Sigma$ and some $k \in \mathbb{I}$.

\vspace{.1in}

Let $\sigma' \in \Sigma$ be any state, 
then
{\scriptsize
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$( 2,\sigma') \mapsto 2$}
\AxiomC{}
\UnaryInfC{$( 3,\sigma') \mapsto 3$}
\BinaryInfC{$( 2 * 3, \sigma')  \mapsto 6$}
\end{prooftree}
%\DisplayProof
}
and
{\scriptsize
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$( 3,\sigma') \mapsto 3$}
\AxiomC{}
\UnaryInfC{$( 3,\sigma') \mapsto 3$}
\BinaryInfC{$( 3 + 3, \sigma')  \mapsto 6$}
\end{prooftree}
}
which shows that regardless of the state, the two expressions
will always produce the same semantics value, namely the integer $6$.
This concludes the proof. $\Box$
\end{frame}


\begin{frame}{Expression Equivalence}

{\bf Problem:} Show that the $+$ operator is commutative.

\end{frame}

\begin{frame}{Expression Equivalence}
\small
{\it Proof: }
We need to show that $a_0 + a_1 \sim a_1 + a_0$ 
for all $a_0$, $a_1 \in \syntaxset{Aexp}$.
We show this by demonstrating that
{\small
\[
( a_0 + a_1,\sigma) \mapsto n
\wedge
( a_1 + a_0,\sigma) \mapsto n
\]
}
for all $\sigma \in \Sigma$ and $n \in \mathbb{I}$.

\vspace{.1in}

Assume that 
{\scriptsize
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$( a_0, \sigma') \mapsto k_0$}
\end{prooftree}
%\DisplayProof
}
and 
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$( a_1, \sigma') \mapsto k_1$}
\end{prooftree}
%\DisplayProof
for some $\sigma' \in\Sigma$ and $k_0$, $k_1 \in \mathbb{I}$.
\end{frame}

\begin{frame}{Expression Equivalence}
Then we can construct the derivations 
{\scriptsize
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$( a_0, \sigma') \mapsto k_0$}
\AxiomC{}
\UnaryInfC{$( a_1, \sigma') \mapsto k_1$}
\RightLabel{, where $k = k_0 + k_1$}
\BinaryInfC{$( a_0 + a_1, \sigma') \mapsto k$}
\end{prooftree}
}
and
{\scriptsize
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$( a_1, \sigma') \mapsto k_1$}
\AxiomC{}
\UnaryInfC{$( a_0, \sigma') \mapsto k_0$}
\RightLabel{, where $k = k_1 + k_0$}
\BinaryInfC{$( a_1 + a_0, \sigma') \mapsto k$}
\end{prooftree}
}
This proves the commutativity of $+$. $\Box$

\vspace{.2in}

{\bf Observation:} Commutativity of the syntactic $+$ operator is provided by the
commutativity of the $+$ operator over the set of integers.
\end{frame}

\begin{frame}{Boolean Expressions}

\small
Recall our production for boolean expressions:
\[
\nonterm{B} ::= \mbox{\bf true} \orbar \mbox{\bf false} \orbar \nonterm{A} = \nonterm{A} \orbar
	\nonterm{A} \le \nonterm{A} \orbar ! \nonterm{B} \orbar \nonterm{B} \&\& \nonterm{B} \orbar 
	\nonterm{B} || \nonterm{B} \orbar (\nonterm{B})
\]

To compute the semantic value of boolean expressions we define an
evaluation function `$\mapsto$', \footnote{\tiny What does the inductive definition of \syntaxset{Bexp} look like?}
\[
\mapsto \co \syntaxset{Bexp} \times \Sigma \rightarrow \mathbb{B},
\]
and write
\[
\pair{be}{\sigma}\mapsto \mbox{\bf t},
\]
with $be \in\syntaxset{Bexp}$, $\sigma\in\Sigma$, and $\mbox{\bf t}\in\mathbb{B}$.

\vspace{.1in}

As in the case of the arithmetic expressions we introduce an $\mathit{eval}$ function in order
to map the syntactic representations of  boolean constants in \syntaxset{T}
into the semantic concepts of the constant in $\mathbb{B}$,
\[
\mathit{eval}\co \syntaxset{T} \rightarrow \mathbb{B}
\]

\end{frame}

\begin{frame}{Boolean Expressions}

\scriptsize
\AxiomC{}
\UnaryInfC{$( {\bf true}, \sigma) \mapsto \mathit{eval}(\bf true)$}
\DisplayProof
\\\vspace{.2in}
\AxiomC{}
\UnaryInfC{$( {\bf false}, \sigma) \mapsto \mathit{eval}(\bf false)$}
\DisplayProof
\\\vspace{.2in}
\AxiomC{$( a_0, \sigma) \mapsto n$}
\AxiomC{$( a_1, \sigma) \mapsto m$}
\RightLabel{\hspace{.1in} if $n$ and $m$ are equal}
\BinaryInfC{$( a_0 = a_1, \sigma) \mapsto true$}
\DisplayProof
\\\vspace{.2in}
\AxiomC{$( a_0, \sigma) \mapsto n$}
\AxiomC{$( a_1, \sigma) \mapsto m$}
\RightLabel{\hspace{.1in} if $n$ and $m$ are not equal}
\BinaryInfC{$( a_0 = a_1, \sigma) \mapsto false$}
\DisplayProof
\\\vspace{.2in}
\AxiomC{$( a_0, \sigma) \mapsto n$}
\AxiomC{$( a_1, \sigma) \mapsto m$}
\RightLabel{\hspace{.1in} if $n$ is less than or equal to $m$}
\BinaryInfC{$( a_0 \le a_1, \sigma) \mapsto true$}
\DisplayProof
\\\vspace{.2in}
\AxiomC{$( a_0, \sigma) \mapsto n$}
\AxiomC{$( a_1, \sigma) \mapsto m$}
\RightLabel{\hspace{.1in} if $n$ is not less than or equal to $m$}
\BinaryInfC{$( a_0 \le a_1, \sigma) \mapsto false$}
\DisplayProof
\\\vspace{.2in}

with ${\bf true}, {\bf false} \in \syntaxset{T}$, $a_0,a_1\in \syntaxset{Aexp}$, $\sigma\in \Sigma$,
and $m,n\in \mathbb{I}$.
\end{frame}


\begin{frame}{Boolean Expressions}

\scriptsize
\AxiomC{$( b,\sigma) \mapsto  true$}
\UnaryInfC{$( ! b, \sigma) \mapsto  false$}
\DisplayProof
\hspace{.2in}
\AxiomC{$( b,\sigma) \mapsto false$}
\UnaryInfC{$( ! b, \sigma) \mapsto  true$}
\DisplayProof
\\\vspace{.2in}
\AxiomC{$( b_0,\sigma) \mapsto  t_0$}
\AxiomC{$( b_1,\sigma) \mapsto  t_1$}
\BinaryInfC{$( b_0 \&\& b_1, \sigma ) \mapsto t$}
\DisplayProof
\\\vspace{.1in}
where  $t$ is $true$ if $t_0 \equiv true$ and $t_1 \equiv  true$, and
is ${false}$ otherwise.
\\\vspace{.2in}
\AxiomC{$( b_0,\sigma) \mapsto  t_0$}
\AxiomC{$( b_1,\sigma) \mapsto  t_1$}
\BinaryInfC{$( b_0 || b_1, \sigma ) \mapsto t$}
\DisplayProof
\\\vspace{.1in}
where  $t$ is ${true}$ if $t_0 \equiv  true$ or $t_1 \equiv  true$, and
is ${false}$ otherwise.

\vspace{.2in}

Here $b,b_0,b_1\in \syntaxset{Bexp}$, $t_0,t_1,t \in \mathbb{B}$, and $\sigma\in\Sigma$.
\end{frame}


\begin{frame}{Expression Equivalence}
As before, our notion of semantic value for expressions leads to a natural equivalence relation 
between boolean expressions:

\[
b_0 \sim b_1 \mbox{ iff } 
 \forall \sigma \in \Sigma, \exists t \in {\mathbb{B}}. \; 
( b_0,\sigma) \mapsto t
\wedge
( b_1,\sigma) \mapsto t,
\]
where $b_0$, $b_1 \in \syntaxset{Bexp}$.

\vspace{.1in}

One way to look at this is that boolean expressions behave analogous to
arithmetic expression except that the base has changed.
\end{frame}

\begin{frame}{Command Evaluation}

Recall our grammar production for commands\footnote{\tiny Inductive definition of the syntactic domain \syntaxset{Com}?}:
\[
\nonterm{C} ::= \mbox{\bf skip} \orbar \nonterm{V} := \nonterm{A} \orbar\nonterm{C}\; ; \nonterm{C} \orbar
	\mbox{\bf if} \; \nonterm{B}\; \mbox{\bf then}\;\nonterm{C}\; \mbox{\bf else}\; \nonterm{C} \; \term{end}\orbar
	\mbox{\bf while}\; \nonterm{B}\; \mbox{\bf  do}\; \nonterm{C}\; \term{end}
\]

In order to design a semantics for commands we have to answer the following questions:
\begin{enumerate}
\item What is the semantic domain for commands? 
\item  What does the evaluation function
look like? 
\end{enumerate}
\end{frame}

\begin{frame}{Command Evaluation}

In our simple imperative language commands modify the state of the computation, that is,
commands map one state into another.  Therefore we define
our evaluation function `$\mapsto$' as,
\[
\mapsto \co \syntaxset{Com} \times \Sigma\rightarrow {\color{red}\Sigma}
\]

and we write, given a command $c \in \syntaxset{Com}$ and some state $\sigma \in \Sigma$ ,
\[
( c, \sigma ) \mapsto \sigma'
\]
where $\sigma' \in \Sigma$ is the state after command $c$ has {\em fully executed}.
\end{frame}

\begin{frame}{Command Evaluation}
Before we can give the full natural semantics for commands we need some more
machinery.  Consider,
\[
( x := 5, \sigma ) \mapsto \sigma'
\]
where $x \in \syntaxset{Loc}$, $5 \in \syntaxset{I}$, and $\sigma$, $\sigma' \in \Sigma$.

\vspace{.1in}

Here, $\sigma'$ is the state $\sigma$ updated to have the value $5$ in location $x$. 

We write,
\[
\sigma' = \sigma[5/x].
\]

\end{frame}

\begin{frame}{Command Evaluation}
More formally, let $\sigma \in \Sigma$, $m \in \mathbb{I}$, and $x$, $y \in \syntaxset{Loc}$.  We write $\sigma[m/x]$ for the state obtained from $\sigma$ by
replacing the contents in $x$ with $m$.  We can define this functionally,
\[
\sigma[m/x](y) = \left\{
	\begin{array}{ll}
	m & \mbox{if $y = x$}\\
	\sigma(y) & \mbox{if $y \ne x$}
	\end{array}
	\right .
\]
$\Rightarrow$ States are ``lookup tables'' for values associated with locations.

\vspace{.1in}

Note that $\sigma[m/x]\co \syntaxset{Loc} \rightarrow \mathbb{I}$ is still considered a function
from locations into the integers.

\end{frame}

\begin{frame}{Command Evaluation}

{\bf Exercises:} Let $\sigma' = \sigma_0[3/q]$ with $3\in \mathbb{I}$ and $q\in \syntaxset{Loc}$,
\begin{itemize}
\item Compute the value of $\sigma'(q)$.
\item Compute the value of $\sigma'(k)$ with $k\in\syntaxset{Loc}$ and $k \ne q$.
\end{itemize}
\end{frame}

\begin{frame}{Command Evaluation}
Assume that all metavariables range over  their appropriate domains and $\sigma$, $\sigma'$, and $\sigma'' \in \Sigma$.
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$( {\bf skip}, \sigma ) \mapsto \sigma$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$( a, \sigma) \mapsto m$}
\UnaryInfC{$( x := a, \sigma) \mapsto \sigma[m/x]$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$( b,\sigma) \mapsto  true$}
\AxiomC{$( c_0, \sigma) \mapsto \sigma'$}
\BinaryInfC{$( \term{if}\; b\; \term{then}\; c_0\; \term{else}\; c_1\;\term{end}, \sigma) \mapsto \sigma'$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$( b,\sigma) \mapsto  false$}
\AxiomC{$( c_1, \sigma) \mapsto \sigma'$}
\BinaryInfC{$( \term{if}\; b\; \term{then}\; c_0\; \term{else}\; c_1\;\term{end}, \sigma) \mapsto \sigma'$}
\end{prooftree}
\end{frame}

\begin{frame}{Command Evaluation}
\begin{prooftree}
\AxiomC{$( c_0, \sigma) \mapsto \sigma''$}
\AxiomC{$( c_1, \sigma'') \mapsto \sigma'$}
\BinaryInfC{$( c_0 ; c_1,\sigma) \mapsto \sigma'$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$( b,\sigma) \mapsto  false$}
\UnaryInfC{$( \term{while}\; b\; \term{do}\; c\;\term{end}, \sigma) \mapsto \sigma$}
\end{prooftree}
\begin{prooftree}
\AxiomC{$( b,\sigma) \mapsto  true$}
\AxiomC{$( c, \sigma) \mapsto \sigma''$}
\AxiomC{$( \term{while}\; b\; \term{do}\; c\;\term{end}, \sigma'') \mapsto \sigma'$}
\TrinaryInfC{$( \term{while}\; b\; \term{do}\; c\;\term{end}, \sigma) \mapsto \sigma'$}
\end{prooftree}
\end{frame}

\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%% end of template1.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

